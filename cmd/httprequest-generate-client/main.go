package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"text/template"

	_ "golang.org/x/tools/go/gcimporter"
	"golang.org/x/tools/go/types"
	"gopkg.in/errgo.v1"
)

// TODO:
// - generate exported types if the parameter/response types aren't exported?
// - deal with literal interface and struct types.
// - copy doc comments from server methods.

var currentDir string

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "usage: httprequest-generate server-package server-type client-type\n")
		os.Exit(2)
	}
	flag.Parse()
	if flag.NArg() != 3 {
		flag.Usage()
	}

	serverPkg, serverType, clientType := flag.Arg(0), flag.Arg(1), flag.Arg(2)

	if err := generate(serverPkg, serverType, clientType); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

type templateArg struct {
	CommandLine string
	PkgName     string
	Imports     []string
	Methods     []method
	ClientType  string
}

var code = template.Must(template.New("").Parse(`
// The code in this file was automatically generated by running
// 	httprequest-generate-client {{.CommandLine}}
// DO NOT EDIT

package {{.PkgName}}
import (
	{{range .Imports}}{{printf "%q" .}}
	{{end}}
)

type {{.ClientType}} struct {
	Client httprequest.Client
}

{{range .Methods}}
{{if .RespType}}
	func (c *{{$.ClientType}}) {{.Name}}(p *{{.ParamType}}) ({{.RespType}}, error) {
		var r {{.RespType}}
		err := c.Client.Call(p, &r)
		return r, err
	}
{{else}}
	func (c *{{$.ClientType}}) {{.Name}}(p *{{.ParamType}}) (error) {
		return c.Client.Call(p, nil)
	}
{{end}}
{{end}}
`))

func generate(serverPkg, serverType, clientType string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	currentDir = cwd

	methods, imports, err := serverMethods(serverPkg, serverType)
	if err != nil {
		return errgo.Mask(err)
	}
	localPkg, err := build.Import(".", currentDir, 0)
	if err != nil {
		return errgo.Notef(err, "cannot open package in current directory")
	}
	arg := templateArg{
		CommandLine: strings.Join(flag.Args(), " "),
		Imports:     imports,
		Methods:     methods,
		PkgName:     localPkg.Name,
		ClientType:  clientType,
	}
	var buf bytes.Buffer
	if err := code.Execute(&buf, arg); err != nil {
		return errgo.Mask(err)
	}
	data, err := format.Source(buf.Bytes())
	if err != nil {
		return errgo.Notef(err, "cannot format source")
	}
	if err := writeOutput(data, clientType); err != nil {
		return errgo.Mask(err)
	}
	return nil
}

func writeOutput(data []byte, clientType string) error {
	filename := strings.ToLower(clientType) + "_generated.go"
	if err := ioutil.WriteFile(filename, data, 0644); err != nil {
		return errgo.Mask(err)
	}
	return nil
}

type method struct {
	Name      string
	ParamType string
	RespType  string
}

func serverMethods(serverPkg, serverType string) ([]method, []string, error) {
	pkg, err := typeCheck(serverPkg)
	if err != nil {
		return nil, nil, err
	}
	obj := pkg.Scope().Lookup(serverType)
	if obj == nil {
		return nil, nil, errgo.Newf("type %s not found in %s", serverType, serverPkg)
	}
	objTypeName, ok := obj.(*types.TypeName)
	if !ok {
		return nil, nil, errgo.Newf("%s is not a type", serverType)
	}
	// Use the pointer type to get as many methods as possible.
	ptrObjType := types.NewPointer(objTypeName.Type())

	imports := map[string]string{
		"github.com/juju/httprequest": "httprequest",
	}
	var methods []method
	mset := types.NewMethodSet(ptrObjType)
	for i := 0; i < mset.Len(); i++ {
		sel := mset.At(i)
		if !sel.Obj().Exported() {
			continue
		}
		name := sel.Obj().Name()
		if name == "Close" {
			continue
		}
		ptype, rtype, err := parseMethodType(sel.Type().(*types.Signature))
		if err != nil {
			fmt.Fprintf(os.Stderr, "ignoring method %s: %v\n", name, err)
			continue
		}
		ptypeStr, err := typeStr(ptype, imports)
		if err != nil {
			return nil, nil, errgo.Notef(err, "cannot generate type for method %s parameter", name)
		}
		rtypeStr, err := typeStr(rtype, imports)
		if err != nil {
			return nil, nil, errgo.Notef(err, "cannot generate type for method %s response", name)
			return nil, nil, err
		}
		methods = append(methods, method{
			Name:      name,
			ParamType: ptypeStr,
			RespType:  rtypeStr,
		})
	}
	var allImports []string
	for path := range imports {
		allImports = append(allImports, path)
	}
	return methods, allImports, nil
}

type typeStrError struct {
	error
}

func typeStrPanic(err error) {
	panic(&typeStrError{err})
}

// typeStr returns the type string to be used when using the
// given type. It adds any needed import paths to the given
// imports map (map from package path to package id).
// TODO fix the case when two packages declare the same id.
func typeStr(t types.Type, imports map[string]string) (_ string, err error) {
	if t == nil {
		return "", nil
	}
	defer func() {
		rerr := recover()
		if rerr == nil {
			return
		}
		rerr1, ok := rerr.(*typeStrError)
		if !ok {
			panic(rerr)
		}
		err = rerr1.error
	}()
	return typeStr0(t, imports), nil
}

// typeStr0 is the recursive version of typeStr.
// It panics with *typeStrError on error.
func typeStr0(t types.Type, imports map[string]string) string {
	switch t := t.(type) {
	case *types.Named:
		if !t.Obj().Exported() {
			typeStrPanic(errgo.Newf("type %s is not exported", t))
		}
		path := t.Obj().Pkg().Path()
		id := imports[path]
		if id == "" {
			pkg, err := build.Import(path, ".", 0)
			if err != nil {
				typeStrPanic(err)
			}
			id = pkg.Name
			imports[path] = id
		}
		return id + "." + t.Obj().Name()
	case *types.Pointer:
		return "*" + typeStr0(t.Elem(), imports)
	case *types.Map:
		return fmt.Sprintf("map[%s]%s",
			typeStr0(t.Key(), imports),
			typeStr0(t.Elem(), imports),
		)
	case *types.Slice:
		return "[]" + typeStr0(t.Elem(), imports)
	case *types.Basic:
		return t.Name()
	case *types.Interface:
		if t.NumEmbeddeds() > 0 || t.NumExplicitMethods() > 0 {
			typeStrPanic(errgo.Newf("only interface{} supported as yet"))
		}
		return "interface{}"
	}
	typeStrPanic(errgo.Newf("unexpected type %s (%T)", t, t))
	panic("not reached")
}

func parseMethodType(t *types.Signature) (ptype, rtype types.Type, err error) {
	mp := t.Params()
	if mp.Len() != 1 && mp.Len() != 2 {
		return nil, nil, errgo.New("wrong argument count")
	}
	ptype0 := mp.At(mp.Len() - 1).Type()
	ptype1, ok := ptype0.(*types.Pointer)
	if !ok {
		return nil, nil, errgo.New("parameter is not a pointer")
	}
	ptype = ptype1.Elem()
	if _, ok := ptype.Underlying().(*types.Struct); !ok {
		return nil, nil, errgo.Newf("parameter is %s, not a pointer to struct", ptype1.Elem())
	}
	rp := t.Results()
	if rp.Len() > 2 {
		return nil, nil, errgo.New("wrong result count")
	}
	if rp.Len() == 2 {
		rtype = rp.At(0).Type()
	}
	return ptype, rtype, nil
}

// typeCheck runs the Go type checker on the package
// with the given path and returns the type-checked package.
func typeCheck(pkgPath string) (*types.Package, error) {
	// TODO put this in a utility package somewhere.

	// We install the package because gcimporter
	// ignores source files by default and uses only
	// the object file data, which may be out of date.
	cmd := exec.Command("go", "install", pkgPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return nil, errgo.Notef(err, "cannot install %s", pkgPath)
	}

	buildPkg, err := build.Import(pkgPath, currentDir, 0)
	if err != nil {
		return nil, errgo.Notef(err, "cannot import %q", pkgPath)
	}
	filter := func(info os.FileInfo) bool {
		for _, name := range buildPkg.GoFiles {
			if info.Name() == name {
				return true
			}
		}
		return false
	}
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, buildPkg.Dir, filter, parser.ParseComments|parser.DeclarationErrors)
	if err != nil {
		return nil, errgo.Notef(err, "cannot parse server package")
	}
	if len(pkgs) != 1 {
		return nil, errgo.Newf("found more than one package")
	}
	pkg, ok := pkgs[buildPkg.Name]
	if !ok {
		return nil, errgo.Newf("package %s not found in parsed package", buildPkg.Name)
	}
	var files []*ast.File
	for _, file := range pkg.Files {
		files = append(files, file)
	}
	typesPkg, err := types.Check(buildPkg.ImportPath, fset, files)
	if err != nil {
		return nil, errgo.Notef(err, "cannot type check %s", buildPkg.ImportPath)
	}
	return typesPkg, nil
}
